# Bubble_Sorting
---
#### 버블 정렬 (Bubble Sorting )
 - 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환을 진행 한다.

#### 버블정렬의 구체적인 개념
- **_int array[10] ={10,50,30,40,60,100,90,80,20,70}_** 배열이 있다고 가정할 경우 첫번째 자료와 두번째 자료 즉 **10 과 50**을 비교, 이후 **50과 30**을 비교 하며 마지막 자료 (N) 과 N-1 의 값을 비교를 진행하며 교환을 진행한다.
- **1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동**하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다

**( Cycle )**
-  첫번째 자료 10과 50을 비교하여 10이 50보다 작기 때문에 교환 하지 않고, 이후 50과 30을 비교 했을 경우 50이 30 보다 크기 때문에 교환을 진행, 50 과 40 을 비교 했을 경우 50이 40보다 크기 떄문에 교환을 진행 하며 **마지막으로는 가장 큰수가 70 자리에 교환 되어 저장**된다.


-  **1회전을 진행 했을 경우 가장 큰수가 맨 끝으로 이동 했음으로  맨 끝의 숫자는 비교 하지 않는다.** 1 회전과 동일하게 인접한 두원소를 비교하여 **마지막 맨끝의 자리수를 1회전이 진행 될 수 록 -1 감소하며 정렬을 진행** 한다 .


`Bubble Sorting C CODE`
```c
#include <stdio.h>
#define MAX 10
int main(void){
	//Bubbel_Sorting 
	int i , j , temp; 
	int array[MAX]={10,50,30,40,60,100,90,80,20,70}; //Sorting 을 진행할 배열 선언  
	
	for(i=0;i<MAX;i++){                             //array[j] 값과 array[j+1] 값을 비교하여 가장 큰 값을 뒤로 보내며 정렬  
		for(j=i;j<MAX-(i+1);j++){
			if(array[j]>array[j+1]){
				temp = array[j];
				array[j]=array[j+1];
				array[j+1]=temp;	
			}		
		}
	}
	printf("After Sorting :");	               //Sorting 후 출력을 하는 코드  
	for(i=0;i<MAX;i++){
		printf(" %d ",array[i]);
	}
	
	return 0;
}

```

#### 버블 정렬의 시간 복잡도 
- 비교 횟수
최상, 평균, 최악 모두 일정
n-1, n-2, … , 2, 1 번 = n(n-1)/2
- 교환 횟수
입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.


---
### Reference 
> https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html
> C언어로 쉽게 풀어쓴 자료구조 개정 3판 